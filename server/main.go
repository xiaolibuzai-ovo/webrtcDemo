// reflect demonstrates how with one PeerConnection you can send video to Pion and have the packets sent back
package main

import (
	"bufio"
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"github.com/pion/interceptor"
	"github.com/pion/interceptor/pkg/intervalpli"
	"github.com/pion/webrtc/v4"
	"io"
	"io/ioutil"
	"os"
	"strings"
)

// nolint:gocognit
func main() {
	// Everything below is the Pion WebRTC API! Thanks for using it ❤️.

	// Create a MediaEngine object to configure the supported codec
	m := &webrtc.MediaEngine{}

	// Setup the codecs you want to use.
	// We'll use a VP8 and Opus but you can also define your own
	if err := m.RegisterCodec(webrtc.RTPCodecParameters{
		RTPCodecCapability: webrtc.RTPCodecCapability{MimeType: webrtc.MimeTypeVP8, ClockRate: 90000, Channels: 0, SDPFmtpLine: "", RTCPFeedback: nil},
		PayloadType:        96,
	}, webrtc.RTPCodecTypeVideo); err != nil {
		panic(err)
	}

	if err := m.RegisterCodec(webrtc.RTPCodecParameters{
		RTPCodecCapability: webrtc.RTPCodecCapability{MimeType: webrtc.MimeTypeOpus, ClockRate: 48000, Channels: 0, SDPFmtpLine: "", RTCPFeedback: nil},
		PayloadType:        111,
	}, webrtc.RTPCodecTypeAudio); err != nil {
		panic(err)
	}

	// Create a InterceptorRegistry. This is the user configurable RTP/RTCP Pipeline.
	// This provides NACKs, RTCP Reports and other features. If you use `webrtc.NewPeerConnection`
	// this is enabled by default. If you are manually managing You MUST create a InterceptorRegistry
	// for each PeerConnection.
	i := &interceptor.Registry{}

	// Use the default set of Interceptors
	if err := webrtc.RegisterDefaultInterceptors(m, i); err != nil {
		panic(err)
	}

	// Register a intervalpli factory
	// This interceptor sends a PLI every 3 seconds. A PLI causes a video keyframe to be generated by the sender.
	// This makes our video seekable and more error resilent, but at a cost of lower picture quality and higher bitrates
	// A real world application should process incoming RTCP packets from viewers and forward them to senders
	intervalPliFactory, err := intervalpli.NewReceiverInterceptor()
	if err != nil {
		panic(err)
	}
	i.Add(intervalPliFactory)

	// Create the API object with the MediaEngine
	api := webrtc.NewAPI(webrtc.WithMediaEngine(m), webrtc.WithInterceptorRegistry(i))

	// Prepare the configuration
	config := webrtc.Configuration{
		ICEServers: []webrtc.ICEServer{
			{
				URLs: []string{"stun:stun.l.google.com:19302"},
			},
		},
	}
	// Create a new RTCPeerConnection
	peerConnection, err := api.NewPeerConnection(config)
	if err != nil {
		panic(err)
	}
	defer func() {
		if cErr := peerConnection.Close(); cErr != nil {
			fmt.Printf("cannot close peerConnection: %v\n", cErr)
		}
	}()

	// 创建轨道，发送视频回浏览器上
	outputVideoTrack, err := webrtc.NewTrackLocalStaticRTP(webrtc.RTPCodecCapability{MimeType: webrtc.MimeTypeVP8}, "video", "pion")
	if err != nil {
		panic(err)
	}
	// Add this newly created track to the PeerConnection
	rtpVideoSender, err := peerConnection.AddTrack(outputVideoTrack)
	if err != nil {
		panic(err)
	}
	// Read incoming RTCP packets
	// Before these packets are returned they are processed by interceptors. For things
	// like NACK this needs to be called.
	go func() {
		rtcpBuf := make([]byte, 1500)
		for {
			if _, _, rtcpErr := rtpVideoSender.Read(rtcpBuf); rtcpErr != nil {
				return
			}
		}
	}()

	// 创建轨道，发送音频回浏览器上
	outputAudioTrack, err := webrtc.NewTrackLocalStaticRTP(webrtc.RTPCodecCapability{MimeType: webrtc.MimeTypeOpus}, "audio", "pion")
	if err != nil {
		panic(err)
	}

	// Add this newly created track to the PeerConnection
	rtpAudioSender, err := peerConnection.AddTrack(outputAudioTrack)
	if err != nil {
		panic(err)
	}
	// Read incoming RTCP packets
	// Before these packets are returned they are processed by interceptors. For things
	// like NACK this needs to be called.
	go func() {
		rtcpBuf := make([]byte, 1500)
		for {
			if _, _, rtcpErr := rtpAudioSender.Read(rtcpBuf); rtcpErr != nil {
				return
			}
		}
	}()

	// Wait for the offer to be pasted
	offer := webrtc.SessionDescription{}
	Decode("eyJ0eXBlIjoib2ZmZXIiLCJzZHAiOiJ2PTBcclxubz0tIDE4ODc5NjU2MTI0Mzc0NzE3ODIgMiBJTiBJUDQgMTI3LjAuMC4xXHJcbnM9LVxyXG50PTAgMFxyXG5hPWdyb3VwOkJVTkRMRSAwIDFcclxuYT1leHRtYXAtYWxsb3ctbWl4ZWRcclxuYT1tc2lkLXNlbWFudGljOiBXTVMgN2U2YzJlNGItNGNlNC00MmE5LTlkZjEtNmYwNzRlOGI3ZTc3XHJcbm09YXVkaW8gMTc0MSBVRFAvVExTL1JUUC9TQVZQRiAxMTEgNjMgOSAwIDggMTMgMTEwIDEyNlxyXG5jPUlOIElQNCAxMjQuMjM4LjYxLjEyN1xyXG5hPXJ0Y3A6OSBJTiBJUDQgMC4wLjAuMFxyXG5hPWNhbmRpZGF0ZTozMDE0NTY5MDg1IDEgdWRwIDIxMjIxOTQ2ODcgMTkyLjE2OC4zLjMwIDUxMDQyIHR5cCBob3N0IGdlbmVyYXRpb24gMCBuZXR3b3JrLWlkIDEgbmV0d29yay1jb3N0IDEwXHJcbmE9Y2FuZGlkYXRlOjI5ODczNzI4ODggMSB1ZHAgMjEyMjI2Mjc4MyAyNDBlOjM0MTo4ZTJjOjQwMTA6MjljMTpmYjFjOjFjYWY6YzZkMCA1MTcxOCB0eXAgaG9zdCBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAyIG5ldHdvcmstY29zdCAxMFxyXG5hPWNhbmRpZGF0ZToxNzU2MjA0MDkyIDEgdWRwIDE2ODU5ODcwNzEgMTI0LjIzOC42MS4xMjcgMTc0MSB0eXAgc3JmbHggcmFkZHIgMTkyLjE2OC4zLjMwIHJwb3J0IDUxMDQyIGdlbmVyYXRpb24gMCBuZXR3b3JrLWlkIDEgbmV0d29yay1jb3N0IDEwXHJcbmE9Y2FuZGlkYXRlOjM0NDU3MDY0NjkgMSB0Y3AgMTUxODIxNDkxMSAxOTIuMTY4LjMuMzAgOSB0eXAgaG9zdCB0Y3B0eXBlIGFjdGl2ZSBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAxIG5ldHdvcmstY29zdCAxMFxyXG5hPWNhbmRpZGF0ZTozNDM1MTU2NDE2IDEgdGNwIDE1MTgyODMwMDcgMjQwZTozNDE6OGUyYzo0MDEwOjI5YzE6ZmIxYzoxY2FmOmM2ZDAgOSB0eXAgaG9zdCB0Y3B0eXBlIGFjdGl2ZSBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAyIG5ldHdvcmstY29zdCAxMFxyXG5hPWljZS11ZnJhZzpaUlZVXHJcbmE9aWNlLXB3ZDpRaCtOcVl0M0ZWYmFHOTRkOUFMWTVabEZcclxuYT1pY2Utb3B0aW9uczp0cmlja2xlXHJcbmE9ZmluZ2VycHJpbnQ6c2hhLTI1NiA5NjpCNDpCMDpBNTpDMzpFMDpGNjpBQjoyMjpBQzpBRjoxMzpBNzo1NTpFNDpGOTozOTo4MToyMDo0Njo3MTo0NjpFMTo3RDo4QzoxMTozNTpGQzpBMjpGNDo3NDo3OFxyXG5hPXNldHVwOmFjdHBhc3NcclxuYT1taWQ6MFxyXG5hPWV4dG1hcDoxIHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnNzcmMtYXVkaW8tbGV2ZWxcclxuYT1leHRtYXA6MiBodHRwOi8vd3d3LndlYnJ0Yy5vcmcvZXhwZXJpbWVudHMvcnRwLWhkcmV4dC9hYnMtc2VuZC10aW1lXHJcbmE9ZXh0bWFwOjMgaHR0cDovL3d3dy5pZXRmLm9yZy9pZC9kcmFmdC1ob2xtZXItcm1jYXQtdHJhbnNwb3J0LXdpZGUtY2MtZXh0ZW5zaW9ucy0wMVxyXG5hPWV4dG1hcDo0IHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnNkZXM6bWlkXHJcbmE9c2VuZHJlY3ZcclxuYT1tc2lkOjdlNmMyZTRiLTRjZTQtNDJhOS05ZGYxLTZmMDc0ZThiN2U3NyBhNmVlZTQ1Ni1kZjQ2LTRjNmItOTljMy01NWMwNzdhNjBmMjVcclxuYT1ydGNwLW11eFxyXG5hPXJ0cG1hcDoxMTEgb3B1cy80ODAwMC8yXHJcbmE9cnRjcC1mYjoxMTEgdHJhbnNwb3J0LWNjXHJcbmE9Zm10cDoxMTEgbWlucHRpbWU9MTA7dXNlaW5iYW5kZmVjPTFcclxuYT1ydHBtYXA6NjMgcmVkLzQ4MDAwLzJcclxuYT1mbXRwOjYzIDExMS8xMTFcclxuYT1ydHBtYXA6OSBHNzIyLzgwMDBcclxuYT1ydHBtYXA6MCBQQ01VLzgwMDBcclxuYT1ydHBtYXA6OCBQQ01BLzgwMDBcclxuYT1ydHBtYXA6MTMgQ04vODAwMFxyXG5hPXJ0cG1hcDoxMTAgdGVsZXBob25lLWV2ZW50LzQ4MDAwXHJcbmE9cnRwbWFwOjEyNiB0ZWxlcGhvbmUtZXZlbnQvODAwMFxyXG5hPXNzcmM6MjE3NjM4ODIyMCBjbmFtZToxTEx2bXFsYlBNd3FwTk9aXHJcbmE9c3NyYzoyMTc2Mzg4MjIwIG1zaWQ6N2U2YzJlNGItNGNlNC00MmE5LTlkZjEtNmYwNzRlOGI3ZTc3IGE2ZWVlNDU2LWRmNDYtNGM2Yi05OWMzLTU1YzA3N2E2MGYyNVxyXG5tPXZpZGVvIDE3NDIgVURQL1RMUy9SVFAvU0FWUEYgOTYgOTcgMTAyIDEwMyAxMDQgMTA1IDEwNiAxMDcgMTA4IDEwOSAxMjcgMTI1IDM5IDQwIDQ1IDQ2IDk4IDk5IDEwMCAxMDEgMTEyIDExMyAxMTYgMTE3IDExOFxyXG5jPUlOIElQNCAxMjQuMjM4LjYxLjEyN1xyXG5hPXJ0Y3A6OSBJTiBJUDQgMC4wLjAuMFxyXG5hPWNhbmRpZGF0ZTozMDE0NTY5MDg1IDEgdWRwIDIxMjIxOTQ2ODcgMTkyLjE2OC4zLjMwIDU2NjU3IHR5cCBob3N0IGdlbmVyYXRpb24gMCBuZXR3b3JrLWlkIDEgbmV0d29yay1jb3N0IDEwXHJcbmE9Y2FuZGlkYXRlOjI5ODczNzI4ODggMSB1ZHAgMjEyMjI2Mjc4MyAyNDBlOjM0MTo4ZTJjOjQwMTA6MjljMTpmYjFjOjFjYWY6YzZkMCA2NTI0NiB0eXAgaG9zdCBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAyIG5ldHdvcmstY29zdCAxMFxyXG5hPWNhbmRpZGF0ZToxNzU2MjA0MDkyIDEgdWRwIDE2ODU5ODcwNzEgMTI0LjIzOC42MS4xMjcgMTc0MiB0eXAgc3JmbHggcmFkZHIgMTkyLjE2OC4zLjMwIHJwb3J0IDU2NjU3IGdlbmVyYXRpb24gMCBuZXR3b3JrLWlkIDEgbmV0d29yay1jb3N0IDEwXHJcbmE9Y2FuZGlkYXRlOjM0NDU3MDY0NjkgMSB0Y3AgMTUxODIxNDkxMSAxOTIuMTY4LjMuMzAgOSB0eXAgaG9zdCB0Y3B0eXBlIGFjdGl2ZSBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAxIG5ldHdvcmstY29zdCAxMFxyXG5hPWNhbmRpZGF0ZTozNDM1MTU2NDE2IDEgdGNwIDE1MTgyODMwMDcgMjQwZTozNDE6OGUyYzo0MDEwOjI5YzE6ZmIxYzoxY2FmOmM2ZDAgOSB0eXAgaG9zdCB0Y3B0eXBlIGFjdGl2ZSBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAyIG5ldHdvcmstY29zdCAxMFxyXG5hPWljZS11ZnJhZzpaUlZVXHJcbmE9aWNlLXB3ZDpRaCtOcVl0M0ZWYmFHOTRkOUFMWTVabEZcclxuYT1pY2Utb3B0aW9uczp0cmlja2xlXHJcbmE9ZmluZ2VycHJpbnQ6c2hhLTI1NiA5NjpCNDpCMDpBNTpDMzpFMDpGNjpBQjoyMjpBQzpBRjoxMzpBNzo1NTpFNDpGOTozOTo4MToyMDo0Njo3MTo0NjpFMTo3RDo4QzoxMTozNTpGQzpBMjpGNDo3NDo3OFxyXG5hPXNldHVwOmFjdHBhc3NcclxuYT1taWQ6MVxyXG5hPWV4dG1hcDoxNCB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDp0b2Zmc2V0XHJcbmE9ZXh0bWFwOjIgaHR0cDovL3d3dy53ZWJydGMub3JnL2V4cGVyaW1lbnRzL3J0cC1oZHJleHQvYWJzLXNlbmQtdGltZVxyXG5hPWV4dG1hcDoxMyB1cm46M2dwcDp2aWRlby1vcmllbnRhdGlvblxyXG5hPWV4dG1hcDozIGh0dHA6Ly93d3cuaWV0Zi5vcmcvaWQvZHJhZnQtaG9sbWVyLXJtY2F0LXRyYW5zcG9ydC13aWRlLWNjLWV4dGVuc2lvbnMtMDFcclxuYT1leHRtYXA6NSBodHRwOi8vd3d3LndlYnJ0Yy5vcmcvZXhwZXJpbWVudHMvcnRwLWhkcmV4dC9wbGF5b3V0LWRlbGF5XHJcbmE9ZXh0bWFwOjYgaHR0cDovL3d3dy53ZWJydGMub3JnL2V4cGVyaW1lbnRzL3J0cC1oZHJleHQvdmlkZW8tY29udGVudC10eXBlXHJcbmE9ZXh0bWFwOjcgaHR0cDovL3d3dy53ZWJydGMub3JnL2V4cGVyaW1lbnRzL3J0cC1oZHJleHQvdmlkZW8tdGltaW5nXHJcbmE9ZXh0bWFwOjggaHR0cDovL3d3dy53ZWJydGMub3JnL2V4cGVyaW1lbnRzL3J0cC1oZHJleHQvY29sb3Itc3BhY2VcclxuYT1leHRtYXA6NCB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDpzZGVzOm1pZFxyXG5hPWV4dG1hcDoxMCB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDpzZGVzOnJ0cC1zdHJlYW0taWRcclxuYT1leHRtYXA6MTEgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6c2RlczpyZXBhaXJlZC1ydHAtc3RyZWFtLWlkXHJcbmE9c2VuZHJlY3ZcclxuYT1tc2lkOjdlNmMyZTRiLTRjZTQtNDJhOS05ZGYxLTZmMDc0ZThiN2U3NyAwMTFiOTllNy1kYWVhLTRiODEtYWE3YS1lN2IwOTBhNWNhNjJcclxuYT1ydGNwLW11eFxyXG5hPXJ0Y3AtcnNpemVcclxuYT1ydHBtYXA6OTYgVlA4LzkwMDAwXHJcbmE9cnRjcC1mYjo5NiBnb29nLXJlbWJcclxuYT1ydGNwLWZiOjk2IHRyYW5zcG9ydC1jY1xyXG5hPXJ0Y3AtZmI6OTYgY2NtIGZpclxyXG5hPXJ0Y3AtZmI6OTYgbmFja1xyXG5hPXJ0Y3AtZmI6OTYgbmFjayBwbGlcclxuYT1ydHBtYXA6OTcgcnR4LzkwMDAwXHJcbmE9Zm10cDo5NyBhcHQ9OTZcclxuYT1ydHBtYXA6MTAyIEgyNjQvOTAwMDBcclxuYT1ydGNwLWZiOjEwMiBnb29nLXJlbWJcclxuYT1ydGNwLWZiOjEwMiB0cmFuc3BvcnQtY2NcclxuYT1ydGNwLWZiOjEwMiBjY20gZmlyXHJcbmE9cnRjcC1mYjoxMDIgbmFja1xyXG5hPXJ0Y3AtZmI6MTAyIG5hY2sgcGxpXHJcbmE9Zm10cDoxMDIgbGV2ZWwtYXN5bW1ldHJ5LWFsbG93ZWQ9MTtwYWNrZXRpemF0aW9uLW1vZGU9MTtwcm9maWxlLWxldmVsLWlkPTQyMDAxZlxyXG5hPXJ0cG1hcDoxMDMgcnR4LzkwMDAwXHJcbmE9Zm10cDoxMDMgYXB0PTEwMlxyXG5hPXJ0cG1hcDoxMDQgSDI2NC85MDAwMFxyXG5hPXJ0Y3AtZmI6MTA0IGdvb2ctcmVtYlxyXG5hPXJ0Y3AtZmI6MTA0IHRyYW5zcG9ydC1jY1xyXG5hPXJ0Y3AtZmI6MTA0IGNjbSBmaXJcclxuYT1ydGNwLWZiOjEwNCBuYWNrXHJcbmE9cnRjcC1mYjoxMDQgbmFjayBwbGlcclxuYT1mbXRwOjEwNCBsZXZlbC1hc3ltbWV0cnktYWxsb3dlZD0xO3BhY2tldGl6YXRpb24tbW9kZT0wO3Byb2ZpbGUtbGV2ZWwtaWQ9NDIwMDFmXHJcbmE9cnRwbWFwOjEwNSBydHgvOTAwMDBcclxuYT1mbXRwOjEwNSBhcHQ9MTA0XHJcbmE9cnRwbWFwOjEwNiBIMjY0LzkwMDAwXHJcbmE9cnRjcC1mYjoxMDYgZ29vZy1yZW1iXHJcbmE9cnRjcC1mYjoxMDYgdHJhbnNwb3J0LWNjXHJcbmE9cnRjcC1mYjoxMDYgY2NtIGZpclxyXG5hPXJ0Y3AtZmI6MTA2IG5hY2tcclxuYT1ydGNwLWZiOjEwNiBuYWNrIHBsaVxyXG5hPWZtdHA6MTA2IGxldmVsLWFzeW1tZXRyeS1hbGxvd2VkPTE7cGFja2V0aXphdGlvbi1tb2RlPTE7cHJvZmlsZS1sZXZlbC1pZD00MmUwMWZcclxuYT1ydHBtYXA6MTA3IHJ0eC85MDAwMFxyXG5hPWZtdHA6MTA3IGFwdD0xMDZcclxuYT1ydHBtYXA6MTA4IEgyNjQvOTAwMDBcclxuYT1ydGNwLWZiOjEwOCBnb29nLXJlbWJcclxuYT1ydGNwLWZiOjEwOCB0cmFuc3BvcnQtY2NcclxuYT1ydGNwLWZiOjEwOCBjY20gZmlyXHJcbmE9cnRjcC1mYjoxMDggbmFja1xyXG5hPXJ0Y3AtZmI6MTA4IG5hY2sgcGxpXHJcbmE9Zm10cDoxMDggbGV2ZWwtYXN5bW1ldHJ5LWFsbG93ZWQ9MTtwYWNrZXRpemF0aW9uLW1vZGU9MDtwcm9maWxlLWxldmVsLWlkPTQyZTAxZlxyXG5hPXJ0cG1hcDoxMDkgcnR4LzkwMDAwXHJcbmE9Zm10cDoxMDkgYXB0PTEwOFxyXG5hPXJ0cG1hcDoxMjcgSDI2NC85MDAwMFxyXG5hPXJ0Y3AtZmI6MTI3IGdvb2ctcmVtYlxyXG5hPXJ0Y3AtZmI6MTI3IHRyYW5zcG9ydC1jY1xyXG5hPXJ0Y3AtZmI6MTI3IGNjbSBmaXJcclxuYT1ydGNwLWZiOjEyNyBuYWNrXHJcbmE9cnRjcC1mYjoxMjcgbmFjayBwbGlcclxuYT1mbXRwOjEyNyBsZXZlbC1hc3ltbWV0cnktYWxsb3dlZD0xO3BhY2tldGl6YXRpb24tbW9kZT0xO3Byb2ZpbGUtbGV2ZWwtaWQ9NGQwMDFmXHJcbmE9cnRwbWFwOjEyNSBydHgvOTAwMDBcclxuYT1mbXRwOjEyNSBhcHQ9MTI3XHJcbmE9cnRwbWFwOjM5IEgyNjQvOTAwMDBcclxuYT1ydGNwLWZiOjM5IGdvb2ctcmVtYlxyXG5hPXJ0Y3AtZmI6MzkgdHJhbnNwb3J0LWNjXHJcbmE9cnRjcC1mYjozOSBjY20gZmlyXHJcbmE9cnRjcC1mYjozOSBuYWNrXHJcbmE9cnRjcC1mYjozOSBuYWNrIHBsaVxyXG5hPWZtdHA6MzkgbGV2ZWwtYXN5bW1ldHJ5LWFsbG93ZWQ9MTtwYWNrZXRpemF0aW9uLW1vZGU9MDtwcm9maWxlLWxldmVsLWlkPTRkMDAxZlxyXG5hPXJ0cG1hcDo0MCBydHgvOTAwMDBcclxuYT1mbXRwOjQwIGFwdD0zOVxyXG5hPXJ0cG1hcDo0NSBBVjEvOTAwMDBcclxuYT1ydGNwLWZiOjQ1IGdvb2ctcmVtYlxyXG5hPXJ0Y3AtZmI6NDUgdHJhbnNwb3J0LWNjXHJcbmE9cnRjcC1mYjo0NSBjY20gZmlyXHJcbmE9cnRjcC1mYjo0NSBuYWNrXHJcbmE9cnRjcC1mYjo0NSBuYWNrIHBsaVxyXG5hPXJ0cG1hcDo0NiBydHgvOTAwMDBcclxuYT1mbXRwOjQ2IGFwdD00NVxyXG5hPXJ0cG1hcDo5OCBWUDkvOTAwMDBcclxuYT1ydGNwLWZiOjk4IGdvb2ctcmVtYlxyXG5hPXJ0Y3AtZmI6OTggdHJhbnNwb3J0LWNjXHJcbmE9cnRjcC1mYjo5OCBjY20gZmlyXHJcbmE9cnRjcC1mYjo5OCBuYWNrXHJcbmE9cnRjcC1mYjo5OCBuYWNrIHBsaVxyXG5hPWZtdHA6OTggcHJvZmlsZS1pZD0wXHJcbmE9cnRwbWFwOjk5IHJ0eC85MDAwMFxyXG5hPWZtdHA6OTkgYXB0PTk4XHJcbmE9cnRwbWFwOjEwMCBWUDkvOTAwMDBcclxuYT1ydGNwLWZiOjEwMCBnb29nLXJlbWJcclxuYT1ydGNwLWZiOjEwMCB0cmFuc3BvcnQtY2NcclxuYT1ydGNwLWZiOjEwMCBjY20gZmlyXHJcbmE9cnRjcC1mYjoxMDAgbmFja1xyXG5hPXJ0Y3AtZmI6MTAwIG5hY2sgcGxpXHJcbmE9Zm10cDoxMDAgcHJvZmlsZS1pZD0yXHJcbmE9cnRwbWFwOjEwMSBydHgvOTAwMDBcclxuYT1mbXRwOjEwMSBhcHQ9MTAwXHJcbmE9cnRwbWFwOjExMiBIMjY0LzkwMDAwXHJcbmE9cnRjcC1mYjoxMTIgZ29vZy1yZW1iXHJcbmE9cnRjcC1mYjoxMTIgdHJhbnNwb3J0LWNjXHJcbmE9cnRjcC1mYjoxMTIgY2NtIGZpclxyXG5hPXJ0Y3AtZmI6MTEyIG5hY2tcclxuYT1ydGNwLWZiOjExMiBuYWNrIHBsaVxyXG5hPWZtdHA6MTEyIGxldmVsLWFzeW1tZXRyeS1hbGxvd2VkPTE7cGFja2V0aXphdGlvbi1tb2RlPTE7cHJvZmlsZS1sZXZlbC1pZD02NDAwMWZcclxuYT1ydHBtYXA6MTEzIHJ0eC85MDAwMFxyXG5hPWZtdHA6MTEzIGFwdD0xMTJcclxuYT1ydHBtYXA6MTE2IHJlZC85MDAwMFxyXG5hPXJ0cG1hcDoxMTcgcnR4LzkwMDAwXHJcbmE9Zm10cDoxMTcgYXB0PTExNlxyXG5hPXJ0cG1hcDoxMTggdWxwZmVjLzkwMDAwXHJcbmE9c3NyYy1ncm91cDpGSUQgMzUxNDA1MDExNSAzMTQwNDA3NDg3XHJcbmE9c3NyYzozNTE0MDUwMTE1IGNuYW1lOjFMTHZtcWxiUE13cXBOT1pcclxuYT1zc3JjOjM1MTQwNTAxMTUgbXNpZDo3ZTZjMmU0Yi00Y2U0LTQyYTktOWRmMS02ZjA3NGU4YjdlNzcgMDExYjk5ZTctZGFlYS00YjgxLWFhN2EtZTdiMDkwYTVjYTYyXHJcbmE9c3NyYzozMTQwNDA3NDg3IGNuYW1lOjFMTHZtcWxiUE13cXBOT1pcclxuYT1zc3JjOjMxNDA0MDc0ODcgbXNpZDo3ZTZjMmU0Yi00Y2U0LTQyYTktOWRmMS02ZjA3NGU4YjdlNzcgMDExYjk5ZTctZGFlYS00YjgxLWFhN2EtZTdiMDkwYTVjYTYyXHJcbiJ9", &offer)

	// Set the remote SessionDescription
	err = peerConnection.SetRemoteDescription(offer)
	if err != nil {
		panic(err)
	}

	// Set a handler for when a new remote track starts, this handler copies inbound RTP packets,
	// replaces the SSRC and sends them back
	peerConnection.OnTrack(func(track *webrtc.TrackRemote, receiver *webrtc.RTPReceiver) {
		codec := track.Codec()
		if strings.EqualFold(codec.MimeType, webrtc.MimeTypeVP8) {
			go func() {
				fmt.Println("MimeTypeVP8")
				for {
					// Read RTP packets being sent to Pion
					rtp, _, readErr := track.ReadRTP()
					if readErr != nil {
						panic(readErr)
					}

					if writeErr := outputVideoTrack.WriteRTP(rtp); writeErr != nil {
						panic(writeErr)
					}
				}
			}()
		} else if strings.EqualFold(codec.MimeType, webrtc.MimeTypeOpus) {
			go func() {
				fmt.Println("MimeTypeOpus")
				for {
					// Read RTP packets being sent to Pion
					rtp, _, readErr := track.ReadRTP()
					if readErr != nil {
						panic(readErr)
					}

					if writeErr := outputAudioTrack.WriteRTP(rtp); writeErr != nil {
						panic(writeErr)
					}
				}
			}()
		}
	})

	// Set the handler for Peer connection state
	// This will notify you when the peer has connected/disconnected
	peerConnection.OnConnectionStateChange(func(s webrtc.PeerConnectionState) {
		fmt.Printf("Peer Connection State has changed: %s\n", s.String())

		if s == webrtc.PeerConnectionStateFailed {
			// Wait until PeerConnection has had no network activity for 30 seconds or another failure. It may be reconnected using an ICE Restart.
			// Use webrtc.PeerConnectionStateDisconnected if you are interested in detecting faster timeout.
			// Note that the PeerConnection may come back from PeerConnectionStateDisconnected.
			fmt.Println("Peer Connection has gone to failed exiting")
			os.Exit(0)
		}

		if s == webrtc.PeerConnectionStateClosed {
			// PeerConnection was explicitly closed. This usually happens from a DTLS CloseNotify
			fmt.Println("Peer Connection has gone to closed exiting")
			os.Exit(0)
		}
	})

	// Create an answer
	answer, err := peerConnection.CreateAnswer(nil)
	if err != nil {
		panic(err)
	}

	// Create channel that is blocked until ICE Gathering is complete
	gatherComplete := webrtc.GatheringCompletePromise(peerConnection)

	// Sets the LocalDescription, and starts our UDP listeners
	if err = peerConnection.SetLocalDescription(answer); err != nil {
		panic(err)
	}

	// Block until ICE Gathering is complete, disabling trickle ICE
	// we do this because we only can exchange one signaling message
	// in a production application you should exchange ICE Candidates via OnICECandidate
	<-gatherComplete

	// Output the answer in base64 so we can paste it in browser
	fmt.Println(Encode(*peerConnection.LocalDescription()))

	// Block forever
	select {}
}

// Allows compressing offer/answer to bypass terminal input limits.
const compress = false

// MustReadStdin blocks until input is received from stdin
func MustReadStdin() string {
	r := bufio.NewReader(os.Stdin)

	var in string
	for {
		var err error
		in, err = r.ReadString('\n')
		if err != io.EOF {
			if err != nil {
				panic(err)
			}
		}
		in = strings.TrimSpace(in)
		if len(in) > 0 {
			break
		}
	}

	fmt.Println("")

	return in
}

// Encode encodes the input in base64
// It can optionally zip the input before encoding
func Encode(obj interface{}) string {
	b, err := json.Marshal(obj)
	if err != nil {
		panic(err)
	}

	if compress {
		b = zip(b)
	}

	return base64.StdEncoding.EncodeToString(b)
}

// Decode decodes the input from base64
// It can optionally unzip the input after decoding
func Decode(in string, obj interface{}) {
	b, err := base64.StdEncoding.DecodeString(in)
	if err != nil {
		panic(err)
	}

	if compress {
		b = unzip(b)
	}

	err = json.Unmarshal(b, obj)
	if err != nil {
		panic(err)
	}
}

func zip(in []byte) []byte {
	var b bytes.Buffer
	gz := gzip.NewWriter(&b)
	_, err := gz.Write(in)
	if err != nil {
		panic(err)
	}
	err = gz.Flush()
	if err != nil {
		panic(err)
	}
	err = gz.Close()
	if err != nil {
		panic(err)
	}
	return b.Bytes()
}

func unzip(in []byte) []byte {
	var b bytes.Buffer
	_, err := b.Write(in)
	if err != nil {
		panic(err)
	}
	r, err := gzip.NewReader(&b)
	if err != nil {
		panic(err)
	}
	res, err := ioutil.ReadAll(r)
	if err != nil {
		panic(err)
	}
	return res
}
